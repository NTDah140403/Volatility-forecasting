```{r setup, include=FALSE}
library(vrtest)
library(tseries)
library(quantmod) 
library(forecast)
library(ggplot2) 
library(ggfortify)
library(dplyr)
library(gridExtra)
library(rugarch)
library(FinTS) 
library(tidyr)
library(ConnectednessApproach) 

```


```{r}
eth_data <- getSymbols("ETH-USD", src = "yahoo", auto.assign = FALSE, 
                       from = "2018-01-01", to = "2024-01-01")
eth_data <- eth_data |> janitor::clean_names()

```

```{r}
chartSeries(eth_data)
```


```{r}
eth_return <- data.frame(eth_data) |> 
  mutate(Return = log((eth_usd_close / lag(eth_usd_close)))) |> 
  na.omit() 
eth_return <- eth_return |> mutate(Date = as.Date(rownames(eth_return)))

# Q1 <- quantile(eth_return$Return, 0.25)
# Q3 <- quantile(eth_return$Return, 0.75)
# IQR_value <- IQR(eth_return$Return)
# 
# # Step 2: Define the lower and upper bounds for outliers
# lower_bound <- Q1 - 1.5 * IQR_value
# upper_bound <- Q3 + 1.5 * IQR_value
# 
# # Step 3: Filter out the outliers based on the Return variable
# eth_return <- eth_return |>
#   filter(Return >= lower_bound & Return <= upper_bound)

```


```{r}
ggplot(eth_return, aes(x = Return)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "skyblue", color = "black", alpha = 0.7) +
  geom_density(color = "red", size = 1) +
  stat_function(fun = dnorm, args = list(mean = mean(eth_return$Return), sd = sd(eth_return$Return)), 
                color = "blue", linetype = "dashed") +
  labs(
    title = "Histogram and Density of Log-Returns",
    x = "Log Returns",
    y = "Density"
  ) +
  theme_minimal()
```



```{r}
acf_values <- acf(eth_return$Return,plot = F)
acf_df <- acf_df <- data.frame(lag = acf_values$lag, acf = acf_values$acf)

acfplot <- ggplot(acf_df, aes(x = lag, y = acf)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_hline(yintercept = c(-1.96/sqrt(length(eth_return$Return)), 1.96/sqrt(length(eth_return$Return))), 
             linetype = "dashed", color = "red") +
  labs(title = "Autocorrelation Function (ACF)", x = "Lag", y = "ACF") +
  theme_minimal()

pacf_values <- pacf(eth_return$Return**2,plot = F)
pacf_df <- pacf_df <- data.frame(lag = pacf_values$lag, acf = pacf_values$acf)

pacfplot <- ggplot(pacf_df, aes(x = lag, y = acf)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_hline(yintercept = c(-1.96/sqrt(length(eth_return$Return)), 1.96/sqrt(length(eth_return$Return))), 
             linetype = "dashed", color = "red") +
  labs(title = "Autocorrelation Function (PACF)", x = "Lag", y = "ACF") +
  theme_minimal()

grid.arrange( acfplot,pacfplot,ncol = 1)
```

```{r}
fit <- Arima(eth_return$Return, order=c(1,0,0))
fit
```

```{r}
r=resid(fit)
library(MTS)
archTest(r)
```

```{r}
rr=r^2
par(mfrow=c(1,2))
acf(as.vector(rr),main="ACF of Squared Residuals"); 
pacf(as.vector(rr),main="PACF of Squared Residuals") # homoscedasticity check
```


```{r}
spec=ugarchspec(variance.model = list(model="sGARCH",garchOrder = c(1, 1)), mean.model = list(armaOrder = c(1,0,0)), distribution.model = 'norm') 
def.fit = ugarchfit(spec = spec, data = eth_return$Return)
print(def.fit)
```

```{r}
plot(def.fit,which = 1)
```


```{r}
par(mfrow = c(1,2))
plot(def.fit,which = 8)
plot(def.fit,which = 9)
```


```{r}
spec2=ugarchspec(variance.model = list(model="sGARCH",garchOrder = c(1, 1)), mean.model = list(armaOrder = c(1,0,0)), distribution.model = 'std') 
def.fit2 = ugarchfit(spec = spec2, data = eth_return$Return)
print(def.fit2)
```

```{r}
plot(def.fit2,which = 1)
```


```{r}
par(mfrow = c(1,2))
plot(def.fit2,which = 8)
plot(def.fit2,which = 9)
```


```{r}
volatilityGarch <- data.frame(coredata(eth_return), VolatilityGarch = sigma(def.fit), VolatilityGarchStd = sigma(def.fit2))
# volatilityPlotGarch<- ggplot(volatilityGarch, aes(x = Date, y = Return)) +
#   geom_line(color = "skyblue",size = 1.2) + geom_line(aes(y = VolatilityGarch),color = "darkblue")+
#   labs(
#     title = "Garch(1,1)",
#     y = "Volatility",
#     x = "Date"
#   ) +
#   theme_minimal()
# volatilityPlotGarch
volatilityGarch_long <- pivot_longer(
  volatilityGarch,
  cols = c(VolatilityGarch, VolatilityGarchStd),
  names_to = "Volatility_Type",
  values_to = "Volatility_Value"
)

# Plot
volatilityPlotGarch <- ggplot(volatilityGarch_long, aes(x = Date)) +
  geom_line(aes(y = Return), color = "skyblue", size = 1.2) +
  geom_line(aes(y = Volatility_Value, color = Volatility_Type), size = 1) +
  labs(
    title = "Garch(1,1): Volatility Comparison",
    y = "Volatility / Return",
    x = "Date",
    color = "Volatility Type"
  ) +
  theme_minimal() +
  scale_color_manual(
    values = c("VolatilityGarch" = "darkblue", "VolatilityGarchStd" = "darkred"),
    labels = c("GARCH Volatility", "GARCH Standardized Volatility")
  )

# Display plot
volatilityPlotGarch

```

```{r}
uncvariance(def.fit)
uncmean(def.fit)
```

```{r}
uncvariance(def.fit2)
uncmean(def.fit2)
```


```{r}
# Extract forecasted volatility
forecast_horizon <- 1000  # Change to desired forecast horizon
garch_forecast <- ugarchforecast(def.fit, n.ahead = forecast_horizon)
garch_forecast
forecast_volatility <- sigma(garch_forecast)

# Create a data frame for plotting

forecast_data <- data.frame(
  Step = 1:forecast_horizon,          # Forecast horizon steps
  Predicted_Volatility = forecast_volatility[1:forecast_horizon] # Forecasted volatility
)

garch_forecast2 <- ugarchforecast(def.fit2, n.ahead = forecast_horizon)
forecast_volatility2 <- sigma(garch_forecast2)

# Create a data frame for both models
forecast_data2 <- data.frame(
  Step = 1:forecast_horizon,                # Forecast horizon steps
  Predicted_Volatility_Std = forecast_volatility2[1:forecast_horizon], # Forecasted volatility (Student's t)
  Predicted_Volatility_Normal = forecast_volatility[1:forecast_horizon] # From def.fit
)

# Plot the forecasted volatilities
ggplot(forecast_data2, aes(x = Step)) +
  geom_line(aes(y = Predicted_Volatility_Normal, color = "Normal GARCH"), size = 1) +
  geom_line(aes(y = Predicted_Volatility_Std, color = "Student's t GARCH"), size = 1) +
  labs(
    title = "Forecasted Volatility: GARCH Models",
    x = "Forecast Step",
    y = "Predicted Volatility",
    color = "Model Type"
  ) +
  scale_color_manual(
    values = c("Normal GARCH" = "blue", "Student's t GARCH" = "red")
  ) +
  theme_minimal()
```



```{r}
eth_data_new <- getSymbols("ETH-USD", src = "yahoo", auto.assign = FALSE, 
                       from = "2024-01-02", to = "2024-11-18")
eth_data_new <- eth_data_new |> janitor::clean_names()
eth_data_new <- data.frame(eth_data_new) |> 
  mutate(Return = log((eth_usd_close / lag(eth_usd_close)))) |> 
  na.omit() 
eth_data_new <- eth_data_new |> mutate(Date = as.Date(rownames(eth_data_new)))
```


```{r}
# progarchspec <- spec
# setfixed(progarchspec) <- as.list(coef(def.fit))
# garchfilter <- ugarchfilter(data = eth_data_new["Return"], spec = progarchspec)
# plot(sigma(garchfilter))
```

```{r}
def.fit@fit$coef
```

```{r}
def.fit2@fit$coef
```


```{r}
# Extract coefficients from the fitted model
coef <- def.fit@fit$coef
mu <- coef["mu"]       # Mean
ar1 <- coef["ar1"]     # AR(1) coefficient
omega <- coef["omega"] # GARCH omega
alpha1 <- coef["alpha1"] # GARCH alpha
beta1 <- coef["beta1"]  # GARCH beta

n <- nrow(eth_data_new)      # Total number of observations
r <- eth_data_new$Return     # Actual returns from the data
a <- numeric(n)              # Residuals
sigma2 <- numeric(n)         # Conditional variance
predicted_returns <- numeric(n)

last = eth_return$Return[2036]
# Initial values
a[1] <- 0  # Residual at time t=1
sigma2[1] <- omega / (1 - alpha1 - beta1)  # Long-run variance
predicted_returns[1] = r[1]

# Recursive calculation
set.seed(123)
for (t in 2:n) {
  # Update conditional variance using GARCH(1,1) equation

  sigma2[t] <- omega + alpha1 * (a[t-1]^2) + beta1 * sigma2[t-1]
  #epsilon_t <- rnorm(1, mean = 0, sd = 1)
  # Update returns using AR(1) mean equation

  a[t] <- r[t] - (mu + ar1 * r[t-1])  # Calculate residual

  #a[t] <- (sqrt(sigma2[t-1]) * epsilon_t)


  predicted_returns[t] <- mu + ar1*r[t-1] #+ (sqrt(sigma2[t]) * epsilon_t)
}

# Prepare results
results <- data.frame(
  Date = eth_data_new$Date,
  Actual_Return = eth_data_new$Return,
  Predict_return = predicted_returns,
  Predicted_Volatility = sqrt(sigma2) # Volatility is the square root of conditional variance
)

# View the first few rows of results
head(results)
```

```{r}
# Extract coefficients from the fitted model
coef <- def.fit2@fit$coef
mu <- coef["mu"]       # Mean
ar1 <- coef["ar1"]     # AR(1) coefficient
omega <- coef["omega"] # GARCH omega
alpha1 <- coef["alpha1"] # GARCH alpha
beta1 <- coef["beta1"]  # GARCH beta

n <- nrow(eth_data_new)      # Total number of observations
r <- eth_data_new$Return     # Actual returns from the data
a <- numeric(n)              # Residuals
sigma2 <- numeric(n)         # Conditional variance
predicted_returns <- numeric(n)

last = eth_return$Return[2036]
# Initial values
a[1] <- 0  # Residual at time t=1
sigma2[1] <- omega / (1 - alpha1 - beta1)  # Long-run variance
predicted_returns[1] = r[1]

# Recursive calculation
set.seed(123)
for (t in 2:n) {
  # Update conditional variance using GARCH(1,1) equation

  sigma2[t] <- omega + alpha1 * (a[t-1]^2) + beta1 * sigma2[t-1]
  #epsilon_t <- rnorm(1, mean = 0, sd = 1)
  # Update returns using AR(1) mean equation

  a[t] <- r[t] - (mu + ar1 * r[t-1])  # Calculate residual

  #a[t] <- (sqrt(sigma2[t-1]) * epsilon_t)


  predicted_returns[t] <- mu + ar1*r[t-1] #+ (sqrt(sigma2[t]) * epsilon_t)
}

# Prepare results
results2 <- data.frame(
  Date = eth_data_new$Date,
  Actual_Return = eth_data_new$Return,
  Predict_return = predicted_returns,
  Predicted_Volatility = sqrt(sigma2) # Volatility is the square root of conditional variance
)

# View the first few rows of results
head(results2)
```


```{r}
# coef <- def.fit@fit$coef
# mu <- coef["mu"]       # Mean
# ar1 <- coef["ar1"]     # AR(1) coefficient
# ma1 <- coef["ma1"]     # MA(1) coefficient
# omega <- coef["omega"] # GARCH omega
# alpha1 <- coef["alpha1"] # GARCH alpha
# beta1 <- coef["beta1"]  # GARCH beta
# 
# n <- nrow(eth_data_new)      # Total number of observations
# r <- eth_data_new$Return     # Actual returns from the data
# a <- numeric(n)              # Residuals
# sigma2 <- numeric(n)         # Conditional variance
# predicted_returns <- numeric(n)
# 
# # Initial values
# a[1] <- 0  # Residual at time t=1
# sigma2[1] <- omega / (1 - alpha1 - beta1)  # Long-run variance
# predicted_returns[1] <- r[1]  # Use the first return as the initial prediction
# 
# # Recursive calculation
# set.seed(123)
# for (t in 2:n) {
#   # Update conditional variance using GARCH(1,1) equation
#   sigma2[t] <- omega + alpha1 * (a[t-1]^2) + beta1 * sigma2[t-1]
#   
#   # Calculate residual
#   a[t] <- r[t] - (mu + ar1 * r[t-1] + ma1 * a[t-1])
#   
#   # Update returns using ARMA(1,1) mean equation
#   predicted_returns[t] <- mu + ar1 * r[t-1] + ma1 * a[t-1]
# }
# 
# # Prepare results
# results <- data.frame(
#   Date = eth_data_new$Date,
#   Actual_Return = eth_data_new$Return,
#   Predict_return = predicted_returns,
#   Predicted_Volatility = sqrt(sigma2) # Volatility is the square root of conditional variance
# )
# 
# # View the first few rows of results
# head(results)
```



```{r}
# volatilityGarch_new <- data.frame(coredata(eth_data_new), volatilityGarch_new = sigma(garchfilter))
# 
# library(patchwork)
# library(gridExtra)
# 
# price_plot <- ggplot(data = eth_data_new, aes(x = Date, y = eth_usd_close)) +
#   geom_line(color = "skyblue") +
#   labs(title = "ETH closed price", x = NULL, y = "Close Price") +
#   theme_minimal()
# 
# volatility_plot <- ggplot(data = volatilityGarch_new, aes(x = Date, y = volatilityGarch_new)) +
#   geom_line(color = "navy") +
#   labs(title = "Volatility", x = "Date", y = "Volatility") +
#   theme_minimal()
# 
# price_plot / volatility_plot + 
#   plot_layout(heights = c(2, 1)) # Adjust relative heights
```


```{r}
# eth_data_new <- eth_data_new |> mutate(actual_vol = runSD(eth_data_new$Return, n = 30)) 
# 
# 
# eth_data_new <- eth_data_new |> mutate(garch_vol = sigma(garchfilter))
# 
# ggplot(eth_data_new, aes(x = Date)) +
#   geom_line(aes(y = actual_vol), color = "blue") +  # Actual volatility in blue
#   geom_line(aes(y = garch_vol), color = "red") +    # GARCH volatility in red
#   labs(title = "Actual vs GARCH Volatility", x = "Date", y = "Volatility") +
#   theme_minimal()
```



```{r}
# k <- 10  # Number of steps ahead
# future_volatility <- numeric(k)
# 
# # Use the last known residual and variance
# a_t_last <- a[n]
# sigma2_t_last <- sigma2[n]
# 
# # Recursive forecast for future volatility
# for (i in 1:k) {
#   # Update conditional variance
#   sigma2_t_last <- omega + alpha1 * (a_t_last^2) + beta1 * sigma2_t_last
#   future_volatility[i] <- sqrt(sigma2_t_last)
#   
#   # Assume residuals are zero for future (optional assumption)
#   a_t_last <- 0
# }
# 
# # Print future volatility predictions
# future_volatility
```


```{r}
# # Plot actual and predicted volatilities
# ggplot(results, aes(x = Date)) +
#   geom_line(aes(y = Predicted_Volatility, color = "Predicted Volatility")) +
#   labs(title = "Volatility Predictions", x = "Date", y = "Volatility") +
#   theme_minimal()
combined_results <- data.frame(
  Date = results$Date,
  Predicted_Volatility_Model1 = results$Predicted_Volatility, # Volatility from results
  Predicted_Volatility_Model2 = results2$Predicted_Volatility # Volatility from results2
)

# Plot actual and predicted volatilities for both models
library(ggplot2)
ggplot(combined_results, aes(x = Date)) +
  geom_line(aes(y = Predicted_Volatility_Model1, color = "Volatility (norm)"), size = 1) +
  geom_line(aes(y = Predicted_Volatility_Model2, color = "Volatility (std)"), size = 1) +
  labs(
    title = "Volatility Predictions from Two Models",
    x = "Date",
    y = "Predicted Volatility",
    color = "Model"
  ) +
  scale_color_manual(
    values = c("Volatility (norm)" = "blue", "Volatility (std)" = "red")
  ) +
  theme_minimal()
```

```{r}
# # Initialize parameters
# n <- nrow(eth_data_new)      # Total number of observations
# r <- eth_data_new$Return     # Actual log returns
# a <- numeric(n)              # Residuals
# sigma2 <- numeric(n)         # Conditional variance
# predicted_returns <- numeric(n)  # Predicted returns
# 
# # Extract coefficients from the fitted model
# mu <- coef["mu"]
# ar1 <- coef["ar1"]
# omega <- coef["omega"]
# alpha1 <- coef["alpha1"]
# beta1 <- coef["beta1"]
# 
# # Initial values
# a[1] <- 0  # Residual at time t=1
# sigma2[1] <- omega / (1 - alpha1 - beta1)  # Long-run variance
# predicted_returns[1] <- r[1]  # Assume first return is observed
# 
# # Recursive calculation
# set.seed(123)  # For reproducibility of random draws
# for (t in 2:n) {
#   # Update conditional variance using GARCH(1,1) equation
#   sigma2[t] <- omega + alpha1 * (a[t-1]^2) + beta1 * sigma2[t-1]
#   
#   # Generate random noise epsilon_t
#   epsilon_t <- rnorm(1, mean = 0, sd = 1)
#   #epsilon_t = 1
#   # Predicted return using r_t = mu + sigma_t * epsilon_t
#   predicted_returns[t] <- mu + ar1*r[t-1] + (sqrt(sigma2[t]) * epsilon_t)
#   
#   # Calculate residual based on actual return
#   a[t] <- r[t] - predicted_returns[t]
# }
# 
# # Prepare results
# results <- data.frame(
#   Date = eth_data_new$Date,
#   Actual_Return = eth_data_new$Return,
#   Predicted_Return = predicted_returns,
#   Predicted_Volatility = sqrt(sigma2) # Volatility is the square root of conditional variance
# )
# 
# # View the first few rows of results
# head(results)
```


```{r}
# # Number of steps ahead to predict
# k <- 10  # Forecast horizon
# 
# # Initialize vectors for future forecasts
# future_returns <- numeric(k)
# future_volatility <- numeric(k)
# 
# # Use the last known values
# last_return <- r[n]
# last_sigma2 <- sigma2[n]
# 
# # Recursive forecast for future returns and volatility
# set.seed(123)  # For reproducibility of random shocks
# for (i in 1:k) {
#   # Generate random noise epsilon_t (white noise)
#   epsilon_t <- rnorm(1, mean = 0, sd = 1)
#   #epsilon_t = 1
#   
#   # Update conditional variance (GARCH equation)
#   last_sigma2 <- omega + alpha1 * (epsilon_t^2) * last_sigma2 + beta1 * last_sigma2
#   future_volatility[i] <- sqrt(last_sigma2)
#   
#   # Update predicted return
#   future_returns[i] <- mu + ar1*last_return + (future_volatility[i] * epsilon_t)
#   
#   # Update for next iteration
#   last_return <- future_returns[i]
# }
# 
# # Combine future results into a data frame
# future_results <- data.frame(
#   Step = 1:k,
#   Predicted_Return = future_returns,
#   Predicted_Volatility = future_volatility
# )
# 
# # View future predictions
# print(future_results)

```

```{r}
# library(ggplot2)
# 
# # Plot predicted vs actual returns
# ggplot(results, aes(x = Actual_Return, y = Predict_return)) +
#   geom_point(color = "blue", alpha = 0.6) +
#   labs(
#     title = "Scatter Plot of Actual vs Predicted Returns",
#     x = "Actual Return",
#     y = "Predicted Return"
#   ) +
#   theme_minimal() +
#   geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed", linewidth = 1) +
#   theme(plot.title = element_text(hjust = 1))
# 
# # Plot predicted volatility
# ggplot(results, aes(x = Date)) +
#   geom_line(aes(y = Predicted_Volatility, color = "Predicted Volatility")) +
#   labs(title = "Predicted Volatility Over Time", x = "Date", y = "Volatility") +
#   theme_minimal() +
#   scale_color_manual(values = c("Predicted Volatility" = "black"))

```

```{r}
# # Calculate errors (residuals)
# errors <- results$Actual_Return - results$Predict_return
# 
# # Mean Squared Error (MSE)
# mse <- mean(errors^2)
# 
# # Root Mean Squared Error (RMSE)
# rmse <- sqrt(mse)
# 
# # Mean Absolute Error (MAE)
# mae <- mean(abs(errors))
# 
# mape <- mean(abs(errors / results$Actual_Return)) * 100
# 
# # Print results
# # cat("MSE:", mse, "\n")
# # cat("RMSE:", rmse, "\n")
# # cat("MAE:", mae, "\n")
# cat("MAPE:", mape, "%\n")
```



```{r}
volatilityGarch_pre <- data.frame(coredata(eth_data_new), volatilityGarch_pre = results$Predicted_Volatility)

library(patchwork)
library(gridExtra)

price_plot <- ggplot(data = eth_data_new, aes(x = Date, y = eth_usd_close)) +
  geom_line(color = "skyblue") +
  labs(title = "ETH closed price", x = NULL, y = "Close Price") +
  theme_minimal()

volatility_plot <- ggplot(data = volatilityGarch_pre, aes(x = Date, y = volatilityGarch_pre)) +
  geom_line(color = "navy") +
  labs(title = "Volatility", x = "Date", y = "Volatility") +
  theme_minimal()

price_plot / volatility_plot + 
  plot_layout(heights = c(2, 1)) # Adjust relative heights
```


```{r}
eth_data_new_2 <- eth_data_new

eth_data_new_2 <- eth_data_new_2 |> mutate(actual_vol = runSD(eth_data_new_2$Return, n = 30)) 


eth_data_new_2 <- eth_data_new_2 |> mutate(garch_vol = results$Predicted_Volatility)

eth_data_new_2 <- eth_data_new_2 |> mutate(garch_vol_std = results2$Predicted_Volatility)

ggplot(eth_data_new_2, aes(x = Date)) +
  geom_line(aes(y = actual_vol), color = "blue") +  # Actual volatility in blue
  geom_line(aes(y = garch_vol), color = "red") +    # GARCH volatility in red
  geom_line(aes(y = garch_vol_std), color = "green") +
  labs(title = "Actual vs GARCH Volatility", x = "Date", y = "Volatility") +
  theme_minimal()
```

```{r}
errors <- eth_data_new_2$actual_vol - eth_data_new_2$garch_vol
errors <- na.omit(errors)
# Mean Squared Error (MSE)
mse <- mean(errors^2)

# Root Mean Squared Error (RMSE)
rmse <- sqrt(mse)

# Mean Absolute Error (MAE)
mae <- mean(abs(errors))

mape <- mean(abs(errors / results$Actual_Return)) * 100

# Print results
cat("\nMSE:", mse, "\n")
cat("RMSE:", rmse, "\n")
cat("MAE:", mae, "\n")
cat("MAPE:", mape, "%\n")

```

```{r}
# Calculate the adjusted return and bounds
results <- results |> 
  mutate(
    Upper_Bound = exp(uncmean(def.fit) + qnorm(0.95) * lag(results$Predicted_Volatility)) * lag(eth_data_new$eth_usd_close),  # Upper bound
    Lower_Bound = exp(uncmean(def.fit) - qnorm(0.95) * lag(results$Predicted_Volatility)) * lag(eth_data_new$eth_usd_close)  # Lower bound
  )

# # Create the plot
# ggplot(results, aes(x = Date)) +
#   geom_line(aes(y = eth_data_new$eth_usd_close, color = "Return"), size = 0.5) +
#   geom_line(aes(y = Upper_Bound, color = "Upper Bound"), linetype = "dashed", size = 0.5) +
#   geom_line(aes(y = Lower_Bound, color = "Lower Bound"), linetype = "dashed", size = 0.5) +
#   labs(
#     title = "Return vs Prediction Bounds",
#     x = "Date",
#     y = "Value",
#     color = "Legend"
#   ) +
#   theme_minimal() +
#   scale_color_manual(
#     values = c("Return" = "blue", 
#                "Upper Bound" = "green", 
#                "Lower Bound" = "red"))

results <- results %>%
  mutate(
    Upper_Bound2 = exp(uncmean(def.fit2) + qnorm(0.95) * lag(results2$Predicted_Volatility))* lag(eth_data_new$eth_usd_close),  # New Upper bound
    Lower_Bound2 = exp(uncmean(def.fit2) - qnorm(0.95) * lag(results2$Predicted_Volatility))* lag(eth_data_new$eth_usd_close)  # New Lower bound
  )

# Create the plot with two sets of bounds
ggplot(results, aes(x = Date)) +
  geom_line(aes(y = eth_data_new$eth_usd_close, color = "Return"), size = 0.6) +  # Actual return
  geom_line(aes(y = Upper_Bound, color = "Upper Bound"), linetype = "dashed", size = 0.6) +  # First upper bound
  geom_line(aes(y = Lower_Bound, color = "Lower Bound"), linetype = "dashed", size = 0.6) +  # First lower bound
  geom_line(aes(y = Upper_Bound2, color = "Upper Bound 2"), linetype = "dotted", size = 0.8) +  # Second upper bound
  geom_line(aes(y = Lower_Bound2, color = "Lower Bound 2"), linetype = "dotted", size = 0.8) +  # Second lower bound
  labs(
    title = "Return vs Prediction Bounds",
    x = "Date",
    y = "Value",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(
    values = c("Return" = "blue", 
               "Upper Bound" = "green", 
               "Lower Bound" = "red",
               "Upper Bound 2" = "purple", 
               "Lower Bound 2" = "orange")
  )
```







